/**
* @file Cipher.h
* @author Ревин Д.К.
* @version 1.0
* @brief Описание класса Cipher
* @date 22.01.2023
* @copyright ИБСТ ПГУ
*/
#pragma once
#include <string>
#include <vector>
#include <iostream>

using namespace std;
/// @brief Класс для шифрования и расшифрования методом табличной маршрутной перестановки
class Cipher
{
private:
/// @brief атрибут, хранящий ключ для шифрования и расшифрования
    int k;
    wstring getValidOpenText(const std::wstring & s);
    wstring getValidCipherText(const std::wstring & s);
    int getValidKey(const int k, const std::wstring & s);
public:
/// @brief Запрещающий конструктор без параметров
    Cipher()=delete;
    /// @brief Конструктор для ключа
     /**@param Ключ - это целочисленное значение
     * @details Число, которое поступило на вход, записывается в "private" атрибут с названием "key"
     */
    Cipher (int w);
    /** @brief Метод , предназначенный для шифрования методом табличной маршрутной перестановки
     *@param Экземляр класса "Cipher", в котором установился ключ
     *@param wstring - строка, которую нужно зашифровать
     * @details
     * <p>Сначала вычисляется размер таблицы по формуле.
     * @code
     * int h;
     * if (s.size()%w.k!=0) {
     *   h=s.size()/w.k+1;
     * } else {
     *   h=s.size()/w.k;
     * }
     *@endcode
     * Затем создаётся двумерный массив типа "wchar_t", который имеет необходимый размер:
     * размер таблицы в строках вычисляется по формуле, а количество столбцов - это ключ, который устанавливается в экземляре класса "Cipher".</p>
     * @code
     * wchar_t a[h][w.k];
     *@endcode
     * <p>Далее в созданный массив записываются символы строки, которую нужно зашифровать. Запись символов просходит по следующему
     * маршруту: слева-направа, сверху-вниз.  То есть, запись происходит построчно.
     * @code
     *  for (int i=0; i<h; i++) {
     *  for (int j=0; j<w.k; j++) {
     *      if (k<s.size()) {
     *          a[i][j]=s[k];
     *         k++;
     *    } else a[i][j]=' ';
     * }
     *}
     *@endcode
     * Внимание!:
     * Если в таблице остаются незаполненные "ячейки", то в них записывается символ "пробела". Такая ситуации может произойти,
     * если длина строки, которую нужно зашивровать, не кратна значению ключа.
     *</p>
     * <p>После записи поступившей на вход строки в таблицу, происходит процесс её шифрования. Он заключается в том, что символы, которые находятся в двумерном массиве записываются в строку типа
     * wstring с именем "code" по следующему маршруту: сверху-вниз, слева-направа. То есть, чтение происходит по столбцам.
     * @code
     * for (int i=0; i<w.k; i++) {
     *     for (int j=0; j<h; j++) {
     *        code+=a[j][i];
     *   }
     * }
     * return code;  
     * @endcode
     *</p>
     * @return зашифрованная строка типа "wstring"
     */
    wstring CoderCipher(Cipher w, wstring& s);
    /** @brief Метод , предназначенный для шифрования методом табличной маршрутной перестановки
     *@param Экземляр класса "Cipher", в котором установился ключ
     *@param wstring - строка, которую нужно расшифровать
     * @details
     * <p>Сначала вычисляется размер таблицы по формуле.
     * @code
     * int h;
     * if (s.size()%w.k!=0) {
     *   h=s.size()/w.k+1;
     * } else {
     *   h=s.size()/w.k;
     * }
     *@endcode
     * Затем создаётся двумерный массив типа "wchar_t", который имеет необходимый размер:
     * размер таблицы в строках вычисляется по формуле, а количество столбцов - это ключ, который устанавливается в экземляре класса "Cipher".</p>
     * @code
     * wchar_t a[h][w.k];
     *@endcode
     * <p>Далее в созданный массив записываются символы строки, которую нужно расшифровать. Запись символов просходит по следующему
     * маршруту: сверху-вниз, слева-направа. То есть, запись происходит по столбцам.
     * @code
     * for (int i=0; i<w.k; i++) {
     *       for (int j=0; j<h; j++) {
     *          a[j][i]=s[k];
     *         k++;
     *    }
     * }
     *@endcode
     * Внимание!: 
     * Если в таблице остаются незаполненные "ячейки", то в них записывается символ "пробела". Такая ситуация может произойти,
     * если длина строки, которую необходимо расшифровать, не кратна значению ключа.
     *@param wstring - строка, которую нужно расшифровать
     *</p>
     * <p>В конечном итоге происходит процесс расшифрования. Он заключается в том, что символы, которые находятся в двумерном массиве записываются в строку типа
     * wstring с именем "decode" по следующему маршруту: сверху-вниз, слева-направа. То есть, чтение происходит построчно.
     * @code
     * for (int i=0; i<h; i++) {
     *    for (int j=0; j<w.k; j++) {
     *       decode+=a[i][j];
     *  }
     * }
     * return decode;
     * @endcode
     *</p>
     * @return расшифрованная строка типа "wstring"
     */
    wstring DecoderCipher(Cipher w, wstring& s);
};
/// @brief Класс, предназначенный для обработки исключений
class cipher_error: public std::invalid_argument
{
public:
    explicit cipher_error (const std::string& what_arg):
        std::invalid_argument(what_arg) {}
    explicit cipher_error (const char* what_arg):
        std::invalid_argument(what_arg) {}
};
